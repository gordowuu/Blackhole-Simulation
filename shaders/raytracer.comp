#version 460 core

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
layout (rgba16f, binding = 0) uniform image2D outputImage;

// Uniforms - Camera
uniform vec3 u_cameraPos;
uniform vec3 u_cameraTarget;
uniform vec3 u_cameraUp;
uniform float u_fov;
uniform float u_aspectRatio;

// Uniforms - Black Hole
uniform float u_blackHoleMass;
uniform float u_blackHoleSpin;
uniform vec3 u_blackHolePos;
uniform float u_schwarzschildRadius;

// Uniforms - Accretion Disk
uniform bool u_showAccretionDisk;
uniform float u_diskInnerRadius;
uniform float u_diskOuterRadius;
uniform float u_diskThickness;

// Uniforms - Rendering
uniform bool u_showEventHorizon;
uniform bool u_showPhotonSphere;
uniform sampler2D u_starfield;

// Constants
const float PI = 3.14159265359;
const float MAX_DISTANCE = 1000.0;
const int MAX_STEPS = 500;  // Reduced from 2000 for better performance
const float STEP_SIZE = 0.1;  // Increased from 0.02 for faster marching
const float MIN_DISTANCE = 0.5;

// Temperature to RGB conversion (simplified blackbody)
vec3 temperatureToRGB(float temp) {
    temp = clamp(temp / 1000.0, 1.0, 40.0);
    
    vec3 color;
    
    // Red
    if (temp <= 66.0) {
        color.r = 1.0;
    } else {
        float t = temp - 60.0;
        color.r = clamp(1.29294 * pow(t, -0.13320), 0.0, 1.0);
    }
    
    // Green
    if (temp <= 66.0) {
        color.g = clamp(0.39008 * log(temp) - 0.63184, 0.0, 1.0);
    } else {
        float t = temp - 60.0;
        color.g = clamp(1.12989 * pow(t, -0.07551), 0.0, 1.0);
    }
    
    // Blue
    if (temp >= 66.0) {
        color.b = 1.0;
    } else if (temp <= 19.0) {
        color.b = 0.0;
    } else {
        float t = temp - 10.0;
        color.b = clamp(0.54321 * log(t) - 1.19625, 0.0, 1.0);
    }
    
    return color;
}

// Geodesic integration for Kerr metric (rotating black hole)
// Returns: direction after curved spacetime propagation
vec3 integrateGeodesic(vec3 pos, vec3 dir, float step, out bool absorbed) {
    absorbed = false;
    
    vec3 relPos = pos - u_blackHolePos;
    float r = length(relPos);
    
    float Rs = u_schwarzschildRadius;
    float M = Rs * 0.5;  // Mass in geometric units
    float a = u_blackHoleSpin * M;  // Spin parameter
    
    // Kerr event horizon: r+ = M + sqrt(M^2 - a^2)
    float eventHorizon = M + sqrt(max(M * M - a * a, 0.01));
    
    // Check if inside event horizon
    if (r < eventHorizon * 1.1) {
        absorbed = true;
        return dir;
    }
    
    // Schwarzschild metric: ds^2 = -(1-Rs/r)dt^2 + (1-Rs/r)^-1 dr^2 + r^2 dΩ^2
    // Kerr adds frame dragging effects
    
    vec3 toCenter = normalize(relPos);
    
    // Gravitational acceleration - stronger for higher mass (via Rs)
    float factor = 1.0 / (r * r);
    float grCorrection = 1.0 + 1.5 * Rs / r; // GR perihelion precession
    
    // Mass affects the strength of gravitational pull
    // Larger Rs means stronger deflection
    vec3 acceleration = -toCenter * (Rs * 0.5) * factor * grCorrection;
    
    // Kerr frame dragging (Lense-Thirring effect)
    // Rotating black holes drag spacetime around them
    if (abs(u_blackHoleSpin) > 0.01) {
        // Frame dragging angular velocity: ω ∝ a*r / (r^3 + a^2*r)
        float r2 = r * r;
        float a2 = a * a;
        float omega = (2.0 * M * a * r) / (r2 * r + a2 * r + 2.0 * M * a2);
        
        // Dragging effect is stronger closer to black hole
        float dragStrength = omega * Rs / r;
        
        // Direction perpendicular to radial (tangential)
        // Spin direction: assume spin axis aligned with y-axis
        vec3 spinAxis = vec3(0.0, sign(u_blackHoleSpin), 0.0);
        vec3 tangent = cross(spinAxis, toCenter);
        
        // Add frame dragging deflection
        acceleration += tangent * dragStrength * abs(u_blackHoleSpin);
    }
    
    // Update velocity (direction)
    vec3 newDir = normalize(dir + acceleration * step);
    
    return newDir;
}

// Ray-disk intersection
bool intersectDisk(vec3 origin, vec3 dir, out float t, out float radius, out vec2 diskCoord) {
    // Disk in XZ plane (y = 0)
    if (abs(dir.y) < 1e-6) return false;
    
    t = -origin.y / dir.y;
    if (t < 0.0) return false;
    
    vec3 hitPoint = origin + t * dir;
    radius = length(hitPoint.xz);
    
    if (radius < u_diskInnerRadius || radius > u_diskOuterRadius) {
        return false;
    }
    
    float phi = atan(hitPoint.z, hitPoint.x);
    diskCoord = vec2(radius, phi);
    
    return true;
}

// Accretion disk temperature and emission
vec3 getDiskEmission(float radius, vec2 diskCoord) {
    // Temperature profile: T ~ r^(-3/4)
    float tempRatio = u_diskInnerRadius / radius;
    float temperature = 100000.0 * pow(tempRatio, 0.75);
    
    // Add some variation
    temperature *= (0.9 + 0.2 * sin(radius * 10.0));
    
    // Convert to color
    vec3 color = temperatureToRGB(temperature);
    
    // Intensity falloff
    float intensity = pow(tempRatio, 2.0);
    intensity = clamp(intensity, 0.0, 10.0);
    
    // Doppler shifting (simplified)
    float phi = diskCoord.y;
    float velocity = sqrt(u_schwarzschildRadius * 0.5 / radius);
    float dopplerShift = 1.0 + velocity * cos(phi) * 0.3;
    
    // Apply doppler to color (shift hue)
    if (dopplerShift > 1.0) {
        color.b *= dopplerShift;  // Blueshift
    } else {
        color.r *= (2.0 - dopplerShift);  // Redshift
    }
    
    return color * intensity * 3.0;
}

// Sample starfield background
vec3 sampleStarfield(vec3 dir) {
    // Convert direction to spherical coordinates for texture sampling
    float phi = atan(dir.z, dir.x);
    float theta = acos(dir.y);
    
    vec2 uv = vec2(phi / (2.0 * PI) + 0.5, theta / PI);
    
    // Simple procedural stars if no texture
    vec3 stars = vec3(0.0);
    
    // Hash function for random stars
    float hash = fract(sin(dot(floor(uv * 1000.0), vec2(12.9898, 78.233))) * 43758.5453);
    if (hash > 0.995) {
        float brightness = hash * 2.0;
        stars = vec3(brightness);
        
        // Some colored stars
        if (hash > 0.998) {
            stars = vec3(0.7, 0.9, 1.0) * brightness;  // Blue stars
        } else if (hash < 0.996) {
            stars = vec3(1.0, 0.8, 0.6) * brightness;  // Red stars
        }
    }
    
    // Add nebula-like background
    float nebula = 0.05 * sin(uv.x * 20.0) * cos(uv.y * 15.0);
    stars += vec3(0.1, 0.05, 0.15) * max(nebula, 0.0);
    
    return stars;
}

// Main ray tracing function
vec4 traceRay(vec3 origin, vec3 direction) {
    vec3 pos = origin;
    vec3 dir = direction;
    vec4 color = vec4(0.0);
    
    bool absorbed = false;
    float totalDistance = 0.0;
    
    // Ray marching
    for (int step = 0; step < MAX_STEPS; step++) {
        // Check accretion disk intersection
        if (u_showAccretionDisk) {
            float t;
            float radius;
            vec2 diskCoord;
            
            if (intersectDisk(pos, dir, t, radius, diskCoord) && t < STEP_SIZE * 2.0) {
                vec3 emission = getDiskEmission(radius, diskCoord);
                color = vec4(emission, 1.0);
                break;
            }
        }
        
        // Integrate geodesic
        dir = integrateGeodesic(pos, dir, STEP_SIZE, absorbed);
        
        if (absorbed) {
            // Ray absorbed by black hole
            color = vec4(0.0, 0.0, 0.0, 1.0);
            break;
        }
        
        // Move along ray
        pos += dir * STEP_SIZE;
        totalDistance += STEP_SIZE;
        
        float r = length(pos - u_blackHolePos);
        
        // Check if escaped
        if (r > MAX_DISTANCE) {
            // Sample background starfield
            vec3 stars = sampleStarfield(dir);
            color = vec4(stars, 1.0);
            break;
        }
        
        // Visual indicators
        if (u_showPhotonSphere) {
            float photonSphereRadius = u_schwarzschildRadius * 1.5;
            if (abs(r - photonSphereRadius) < 0.1) {
                color = vec4(1.0, 1.0, 0.0, 1.0);
                break;
            }
        }
    }
    
    // Gravitational redshift based on potential
    float r = length(origin - u_blackHolePos);
    float redshift = sqrt(1.0 - u_schwarzschildRadius / max(r, u_schwarzschildRadius * 1.1));
    color.rgb *= redshift;
    
    return color;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageDims = imageSize(outputImage);
    
    // Check bounds
    if (pixelCoords.x >= imageDims.x || pixelCoords.y >= imageDims.y) {
        return;
    }
    
    // Calculate ray direction
    vec2 uv = vec2(pixelCoords) / vec2(imageDims);
    uv = uv * 2.0 - 1.0;  // [-1, 1]
    uv.x *= u_aspectRatio;
    
    // Camera setup
    vec3 forward = normalize(u_cameraTarget - u_cameraPos);
    vec3 right = normalize(cross(forward, u_cameraUp));
    vec3 up = cross(right, forward);
    
    // Calculate ray direction with FOV
    float fovRadians = radians(u_fov);
    float tanHalfFov = tan(fovRadians * 0.5);
    
    vec3 rayDir = normalize(
        forward + 
        right * uv.x * tanHalfFov + 
        up * uv.y * tanHalfFov
    );
    
    // Trace ray
    vec4 color = traceRay(u_cameraPos, rayDir);
    
    // Write to output
    imageStore(outputImage, pixelCoords, color);
}
